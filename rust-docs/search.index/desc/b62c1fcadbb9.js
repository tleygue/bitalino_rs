rd_("BdI/O failures from stdlib operations.AjContains the success valueBjCRC check did not validate frame contents.AhContains the error valueBn1 Hz - for very slow signals or battery savingBiCreate a new frame with the given values.BjSet PWM output value (BITalino 2.0+ only).ClSequence number (0-15, wraps around). Use this to detect \xe2\x80\xa6Bj10 Hz - suitable for respiration, slow EDAAoReturns the argument unchanged.00000000BaCalls <code>U::from(self)</code>.00000000AfStop data acquisition.BmA single data frame from the BITalino device.Bl100 Hz - good for EDA, some EMG applicationsCfStart data acquisition at the specified sampling rate.CbGet the current device state (BITalino 2.0+ only).Ci1000 Hz - required for ECG, EMG, high-quality acquisitionBoConvenience result alias for driver operations.AiSerial-port layer errors.CjAnalog channel values (10-bit resolution, 0-1023). The \xe2\x80\xa6ChAnalog channel values (A1-A6, 10-bit resolution 0-1023).BgThe frames that were successfully read.BgDevice commands that returned an error.AiPairing handshake failed.CdOperations that exceeded their allotted time budget.CcBattery channel raw value (10-bit, 0-1023). Use \xe2\x80\xa6CcRFCOMM channel to connect to (BITalino default: 1).CmDigital input channels (4 channels: I1, I2, O1, O2). Each \xe2\x80\xa6BhDigital channel states [I1, I2, O1, O2].CkConvert sampling rate to protocol bits for the set-rate \xe2\x80\xa6AhSet digital output pins.BbQuery the device firmware version.AgBITalino device driver.CjAdapter scan failed to discover the requested MAC address.CiDevice reported it is not ready for the requested action.BiViolations of the BITalino wire protocol.C`Bluetooth-related issues (pairing/connectivity).BhGet the sampling period in microseconds.AoLow-level RFCOMM socket errors.CgResult of reading frames, including timing information.CfNumber of CRC errors encountered (frames that were \xe2\x80\xa6ChGet the time since acquisition started, in microseconds.CgPer-operation I/O timeout applied to the RFCOMM socket.BdRead a single frame from the device.BnDevice state information (BITalino 2.0+ only).BlTop-level driver errors surfaced to callers.BjBITalino Rust driver with Python bindings.CmCreate a Bitalino driver from an already-connected RFCOMM \xe2\x80\xa6BoMaximum retry attempts for establishing RFCOMM.BeRead multiple frames from the device.CkDelay between retries (exponential backoff uses this as \xe2\x80\xa6BfRFCOMM connection was not established.CeSimple RFCOMM stream that behaves like a blocking \xe2\x80\xa6CbSupported sampling rates for BITalino acquisition.BhCheck if this is a BITalino 2.0+ device.BiHow long to wait for pairing to complete.AnGet the read timeout duration.BoHow long to scan for the device before failing.CeTimestamp when the batch read started (for timing \xe2\x80\xa6AnGet the current sampling rate.CjNumber of sequence discontinuities detected (potential \xe2\x80\xa6ClBluetooth-specific failures separated from transport and \xe2\x80\xa6DhConnect to a BITalino via serial port (e.g., <code>/dev/rfcomm0</code>).ClCheck if battery is low based on threshold. Returns true \xe2\x80\xa6CcApproximate battery voltage based on raw ADC value.ClStart data acquisition with a specific SamplingRate enum \xe2\x80\xa6CmParse a u16 value into a SamplingRate, returning an error \xe2\x80\xa6ChPair and open a stream to the sensor using an RFCOMM \xe2\x80\xa6CiVerify the connection is actually established and usable.BiCurrent battery threshold setting (0-63).CkInitialize logging for Rust binaries (stderr formatter) \xe2\x80\xa6CfRead multiple frames with timing and error statistics.CkHigh level connector that pairs the device and opens an \xe2\x80\xa6ClInitialize the Python-facing logging bridge so Rust logs \xe2\x80\xa6B`Set the battery threshold level.CjReset the cached per-target Python loggers (call after \xe2\x80\xa6")